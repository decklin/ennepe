Introduction
============

Mnemosyne is a simple blogging system which generates static files. You
provide it with some entries, which are stored in an ordinary Maildir, a
layout, which is a directory tree indicating where these entries should
go, and some styles, which are EmPy templates.

The layout tree may contain ordinary files, such as images, stylesheets,
or constant pages, and Python scripts, which will be used to generate
variable pages, XML feeds, or anything else you wish.

Requirements
============

* Python, probably at least version 2.3. I suspect 2.2 would work, but I
  have not tried it.

* If you wish to use reStructuredText to format entries as HTML, as the
  default configuration does, docutils. You could also replace this with
  PyMarkdown, PyTextile, or nothing at all.

* EmPy, available at http://www.alcyone.com/pyos/empy/.

* Something that will allow you to create, add to and edit your Maildir.
  I use procmail and Mutt.

Configuration
=============

A Mnemosyne blog starts with a configuration file, which is a Python
script. The example provided in ``example/config.py`` explains what it
can do and what variables can be set. By default, Mnemosyne looks for
this file in ``~/Mnemosyne/config.py``.

Usage
=====

To regenerate your blog, simply run ``mnemosyne``, or, if your config
lives in a different location, ``mnemosyne path/to/config.py``. By
default, only pages for which the applicable entries or layout have been
changed since the page was last written will be evaluated; you can
override this and rebuild the entire blog with the ``--force`` option.
(At the moment, this is your only recourse if you change your styles.)

Layout
======

Layout scripts are also written in Python. Apart from any local
variables defined in the blog's configuration, they will be given the
following:

* ``muse``: a ``mnemosyne.Muse`` object, the thing that generates the
  blog. This contains many useful attributes, most importantly:

  - ``muse.entries``: the list of all entries in the blog.

  - ``muse.expand(style, locals)``: a callback function which opens an
    EmPy style and expands it with the provided local variables.

  - ``muse.escape``: a callback function which escapes HTML characters,
    for use in RSS or non-XHTML Atom feeds.

* ``entries``: the subset of entries that apply to the particular file
  being generated. In an archive page, for example, this would be only
  the entries in that particular year, week, or whatever.

* ``write(s)``: Another callback function, which will take the provided
  data (a string) and actually write it out to the file being generated.
  Generally, this will be the last thing you call once you put the rest
  of the page together.

Files in the top level directory of your layout will be evaluated with
all the entries in the blog. However, you can create files or
directories with a name like ``__year__``, and it will create files (or,
in this case, directories) named ``2006``, ``2007``, etc, which will be
evaluated with only the entries for that year.

You can do the same thing for attributes which have multiple values, as
well: for example, a directory named ``__tags__`` will be evaluated for each
tag that appears on an entry, even if the tags are stored as a list.

The values for all these expansions come from the attributes of
mnemosyne's Entry class. Several useful ones, such as ``subject`` and
``tags``, are provided by default: if you wish to define more, you may
add a mixin class to your configuration, with some specially-named
methods. Attributes may be calculated at initialization or only when
needed. When generating file or directory names, the attributes' repr()
is used, so that dates, subject lines, and so on may be appropriately
formatted.

Please refer to ``example/layout`` to see how this might all come
together.

Styles
======

It would be quite cumbersome for layout scripts to generate an entire
page by themselves, so ``mnemosyne.Muse``'s ``expand`` method allows you
to use styles to do the hard work. Styles are EmPy templates; to get an
idea of what you can do with them (which is far beyond the scope of this
document), refer to EmPy's documentation or look in ``example/style``.

Writing Layouts and Styles
==========================

For each entry ``e``, the following attributes (plus any you define) are
available:

* ``m``: the message that the entry was created from. Initially, only
  the headers have been read; the rest is read when you access
  ``e.content``.

* ``date``: a time-tuple indicating the date on the Date: header.

* ``mtime``: a time-tuple indicating when the message's Maildir file was
  created. This is not the mtime of the file itself! Messing with
  Maildirs by hand is not recommended. To edit an entry, open the
  Maildir in mutt and hit the "e" key on its message.

* ``content``: the body of the entry, processed with reStructuredText.
  Its repr() is the first 100 characters of the unprocessed body
  (suitable for perhaps a summary feed).

* ``subject``: The contents of the Subject header. Its repr() is a
  URL-cleaned (at most 3 words) version of same, with a number appended
  to make each one unique within a given day: 'subject', 'subject-1',
  'subject-2', etc. These are calculated on startup in chronological
  order so that they are always the same.

* ``id``: The Message-Id: header. Its repr is a tag: URL suitable for an
  Atom feed, as described in
  http://diveintomark.org/archives/2004/05/28/howto-atom-id.

* ``author``: Name from the From: header. Its repr() is the URL-cleaned
  version, in case you want to categorize a multi-author blog by author
  name.

* ``email``: Email address from the From: header. Its repr() is
  something like 'decklin at red dash bean dot com'.

* ``tags``: A list of the contents of the X-Tags: header, split by
  commas. URL-cleaned repr()s for tag categorization.

* ``year``, ``month``, ``day``: What the names imply. The values are
  ints; the repr()s are formatted with ``time.strftime``.

Future and Caveats
==================

I fully intend to write an SQLite backend once someone complains that it
takes too long to load their 100,000 entries. Be loquacious. At the
moment, however, Mnemosyne depends on the Maildir really being a Maildir
(for reliable modification times) and the standard ``email`` and
``mailbox`` modules, which could stand to be a little more generic.

All of the custom-lazy-attribute, underscored-directories, and
DWIM-key-inversion deep magic may or may not be good Python style.
Comments and suggestions are welcome.

About the Name
==============

Mnemosyne, in Greek mythology, is the personification of memory and
mother of the muses, goddesses whom poets would invoke to help them tell
a story. The metaphor, hopefully, should be obvious.

Author and Copyright
====================

Copyright Â© 2006 Decklin Foster <decklin@red-bean.com>.

License
=======

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
